package hello.proxy.config.v6_aop;

import hello.proxy.config.AppV1Config;
import hello.proxy.config.AppV2Config;
import hello.proxy.config.v6_aop.aspect.LogTraceAspect;
import hello.proxy.trace.logtrace.LogTrace;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@Import({AppV1Config.class, AppV2Config.class})
public class AopConfig {

    @Bean
    public LogTraceAspect logTraceAspect(LogTrace logTrace){
        return new LogTraceAspect(logTrace);
    }
    /*
     * AnnotationAwareAspectJAutoProxyCreator 라는 클래스는 이전에 어드바이저를 빈으로 등록해 놓으면 자동으로 프록시를 만들고
     * 프록시를 적용한다고 했다. 여기에 @AspectJ 를 처리하는 기능까지 추가되어서 @AspectJ 를 포인트 컷으로, 로직을 어드바이스로 인식하고
     * Advisor 로 만들어서 저장하는 기능도 한다. 그래서 이름 앞에 AnnotationAware (어노테이션 인식) 하는 기능을 가지고 있다고 쓴다 한다.
     *
     * 정리 -> @Aspect 는 어드바이저를 생성한다.
     * 생성할 땐 어드바이저 빌더라는 곳에 앞에서 우리가 손수 구현했던 것 처럼 AspectJExpressionPointcut 클래스를
     * 통해서 어드바이저 ( 포인트 컷, 어드바이스) 를 만들어서 캐시해 놓는다. (미리 저장해두고 쓴다.)
     *
     * 1. 스프링이 어스펙트가 붙은 클래스나, 빈을 다 조회한다.
     * 2. 빈을 빈 후처리기에 던진다.
     * 3. 스프링 컨테이너에 (1) 어드바이저를 직접 등록, (2) 어스펙트가 붙은 클래스 어드바이저 조회 (어드바이저 빌더에서 조회)
     * 4. 프록시 적용 대상을 포인트 컷을 확인해 하나라도 조건이 만족하면 프록시를 적용.
     * 5. 프록시를 스프링 빈으로 등록하며 만약 프록시 적용 대상이 아니라면 원본 객체를 반환.
     *
     */

    /*
     * 초기 부가기능을 한군데에 분리하고 관리하도록 했다. 그리고 그로 인해 이런 부가기능들을 어디에 적용해야하는지도 선택하게 하는 기능도
     * 추가 되어 만들어졌다. 어디에 적용할 것인가 + 어떤 로직을 적용할 것인가 -> aspect 라고 한다.
     * 우리가 이번에 알아본 aspect 또한 그 기능이며, 포인트 컷 + 어드바이스 -> 어드바이저 또한 aspect 라는 기능이다.
     *
     * 우리 말로 따지면 aspect 는 관점이라는 뜻이다. 어플리케이션을 바라보는 관점을 기능 중심이 아닌 횡단 관심의 입장에서 바라보자는 것이다.
     * 이런 방식을 우리는 관점 지향 프로그래밍이라고 한다. 기존에 한군데에 모아 놓고 관리하며 OOP 로 적용하는데에 한계를 느낀 개발자들은 OOP
     * 의 이런 단점을 보조하는 목적으로 만든 프로그래밍이다.
     *
     * AOP 의 대표적인 구현으로 AspectJ 프레임워크가 존재한다. 또, 스프링도 우리가 지금까지 적어왔던 방식으로 AOP 를 적용하기도 한다.
     * 하지만 이런 것 또한 대부분의 ASPECTJ 문법을 차용하고, ASPECTJ 가 제공하는 기능의 일부만 제공한다.
     */

    /*
     * AOP 를 쓰지 않을 때 모듈(핵심 로직)에 부가기능을 아예 부착하는 방법이 있다. 지금까지 한 방법이 런타임 시점에 프록시를 이용해 부가기능을 붙였다면,
     * 이번에 설명할 방법은 컴파일 시점에 적용하는 방법과, 클래스 로딩 시점에 적용하는 방법 두가지를 나열한다.
     *
     * 1. JAVA 소스코드를 컴파일하면 .class 파일이 생성이 된다. 컴파일 중간에 컴파일러가  부가기능 로직을 붙여버린다.
     * -> aspect 가 제공하는 특별한 컴파일러를 사용함으로써 부가기능을 적용할 수 있다. 디컴파일 하면 그 중간 호출 코드를 볼 수 있다.
     *
     * 부가기능 코드가 컴파일 된 코드 주변에 실제로 붙어버린다.
     * AspectJ 컴파일러는 Aspect 를 확인해서 해당 클래스가 적용 대상인지 먼저 확인하고 적용 대상인 경우에 부가 기능 로직을 적용한다.
     * 로직에 부가 기능 로직이 추가 되는 이 것을 위빙이라고 한다.
     *
     * 대부분 복작해서 사용하지 않는다.
     *
     *
     * 2. 자바를 실행하면 컴파일 결과인 .class 파일을 클래스 로더라는 곳에 올린다. 이 적재 과정을 jvm 에 올리는 과정이라고 하는데 이 때 중간에서
     * .class 파일을 조작한 다음 jvm (클래스 로더) 에 적재한다. -> 바이트 코드를 조작한다. 적용하는 이 방식을 로드 타임 위빙이라고 함.
     *
     * 로드 타임 위빙은 자바를 실행할 때 특별한 옵션을 사용해서 클래스 로더 조작기를 지정해야 하는데, 이게 상당히 까다롭고 복잡하다.
     */

    /*
        스프링 AOP
     * 우리가 사용하는 방식은 런타임 시점에 DI나 빈 포스트 프로세서를 이용해서 복잡한 프록시 생성과정을 거쳐 실행해야한다.
     * 위의 방식들은 진짜 코드에 낌어 넣는거라 생성이고 뭐고 다 필요 없이 그냥 갖다 쓰기만 하면 된다.
     *
     * 프록시를 사용하면 메서드 단에만 적용이 되며, 적용가능한 범위가 컨테이너가 관리하는 빈에 국한된다.
     *
     *
     * 런타임 시점의 방식의 또 다른 단점은 생성자나 그런데는 말고 일반 오버라이드 되는 메서드에 대해서만 프록시적용이 가능하다.
     * 반면에 컴파일이나 클래스 로딩 시점에서는 코드를 아까 말했다 시피 갈아 끼우는 거라 (일체를 만드는 것) 그냥 갖다 쓰기만 하면 된다.
     *  역시 생성자에도 적용이 가능하다.
     *
     *
     *
     *
     *
     * AOP 프레임 워크 사용하게 되면 지금까지 학습한 메서드 위치 뿐만이 아니라 생성자, 필드, 값 접근, static 메서드 등등에 적용할 수 있다.
     * AspectJ 를 사용해서 컴파일 시점과 클래스 로딩 시점에 적용하는 AOP 는 바이트코드를 실제 조작하기 대문에 모든 지점에 적용이 가능하다.
     *
     *
     * 조인 포인트
        어드바이스가 적용될 수 있는 위치, 메소드 실행, 생성자 호출, 필드 값 접근, 스태틱메서드 접근같은 프로그램 실행 중 시점.
        스프링 AOP 는 프록시 방식을 사용하므로 조인 포인트는 항상 메서드 실행 지점으로 생각하면 된다.
     *
       포인트 컷
            조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능.
            주로 AspectJ 표현식을 사용해서 지정한다.
            프록시를 사용하는 스프링 AOP 는 메서드 실행 지점만 포인트 컷으로 선별 가능.
     *
        타겟
            어드바이스를 받는 객체, 포인트 컷으로 결정된 실질된 아이들.
     *
        어드바이스
            부가 기능
            AROUND , BEFORE , AFTER 등과 같은 다양한 종류의 어드바이스가 존재

        위빙
            포인트 컷으로 결정한 타겟의 조인 포인트에 어드바이스를 적용하는 것.
            위빙을 통해 핵심 기능 코드에 영향을 주지 않고 부가 기능을 추가할 수 있음.
            AOP 적용을 위해 애스펙트를 객체에 연결한 상태
                컴파일 타임
                로드 타임
                런타임, 스프링 AOP 는 런타이므 프록시 방식
        AOP 프록시
            AOP 기능을 구현하기 위해 만든 프록시 객체, 스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시 이다.
     * */

}
